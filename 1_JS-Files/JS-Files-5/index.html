<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="CSS\style_zero.css">
    <!-- <link rel="stylesheet" href="CSS\style.css"> -->
    <link rel="stylesheet" href="../../CSS/style.css">
    <!------------------------------------Fonts------------------------------------>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!------------------------------------Highlights.js------------------------------------>
    <link rel="stylesheet" href="../../CSS/vs2015.min.css">
    <title>JS lesson #5. Оператори.</title>
</head>
<body>
    <header>
        <h1>
            <a class = "main_page_link" href="../../index.html">JavaScript</a>
            <hr>
        </h1>
        
        <a class="previous_link" href="../JS-Files-4/index.html"></a>
        <h2  class="suptitle_text">Урок №5<span class="lesson_name">Про оператори</span></h2>
        <a class="next_link" href="../JS-Files-6/index.html"></a>
    </header>

    <div class="suptitle">
        <a class="previous_link" href="../JS-Files-4/index.html"></a>
        <h2 class="suptitle_text suptitle_text--second">Урок №5</h2>
        <a class="next_link" href="../JS-Files-6/index.html"></a>
    </div>

    <div class="suptitle_list">
        <div class="suptitle_list_block">
            <div class="suptitle_list_block_header">
                <div class="close_button">X</div>
            </div>
            <div class="suptitle_list_content">
                <p id="suptitleItem1">Основні терміни</p>
                <p id="suptitleItem2">Спеціальні можливості</p>
                <!-- <p id="suptitleItem3">Приорітет операторів</p> -->
                <p id="suptitleItem4">Оператор присвоєння</p>
                <p id="suptitleItem5">Суміщені оператори</p>
                <p id="suptitleItem6">Інкремент/декремент</p>
                <p id="suptitleItem7">Оператор кома ","</p>
                <p id="suptitleItem8">Побітові оператори</p>
                <p id="suptitleItem9">Оператори порівняння</p>
                <p id="suptitleItem10">Порівняння рядків</p>
                <p id="suptitleItem11">Порівняння різних типів</p>
                <p id="suptitleItem12">Строге порівняння</p>
                <p id="suptitleItem13">Порівняння null і undefined</p>
                <p id="suptitleItem14">Порівняння null і 0</p>
                <p id="suptitleItem15">Непорівнюване значення undefined</p>
                <p id="suptitleItem16">Як уникнути проблем</p>
                <p id="suptitleItem17">Логічні оператори</p>
                <p id="suptitleItem18">Оператор || (АБО)</p>
                <p id="suptitleItem19">Оператор && (І)</p>
                <p id="suptitleItem20">Оператор ! (НЕ)</p>
                <p id="suptitleItem21">Оператор ?? (нульового об'єднання/об'єднання з null)</p>
                <p id="suptitleItem22">Приорітет операторів. Асоціативність</p>
            </div>
        </div>
    </div>
    
    <div id = "top_button" class="top_button">
    </div>

    <div class="block block1">
        <h3 class="block-title">Основні терміни</h3>
        <div class="block-content" >
            <p>
                Всі оператори в JS можна поділити на 3 групи: 
                <ul>
                    <li>базові (математичні) оператори;</li>
                    <li>оператори порівняння;</li>
                    <li>логічні оператори.</li>
                </ul>
            </p>
            <p><b>Операнд</b> - це те, до чого застосовується оператор; їх ще називають аргументами.</p>
            <p><b>Унарний оператор</b> - це оператор, який застосовується до одного операнда.</p>
            <p><b>Бінарний оператор</b> - це оператор, який застосовується до двох операндів.</p>
            <p>
                Наприклад, символ "-" може означати як від'ємний оператор (унарний оператор, що змінює знак),
                так і оператор віднімання (бінарний оператор, що віднімає одне число від іншого), 
                залежно від ситуації.
            </p>
            <p>
                У JS підтримуються насупні математичні оператори:
                <ul>
                    <li>додавання "+";</li>
                    <li>віднімання "-";</li>
                    <li>множення "*";</li>
                    <li>ділення "/";</li>
                    <li>взяття частки від ділення "%";</li>
                    <li>піднесення до степеня "**".</li>
                </ul>
            </p>
        </div>
    </div>

    <div class="block block2">
        <h3 class="block-title">Спеціальні можливості</h3>
        <div class="block-content" >
            <p>
                <b>Бінарний "+"</b> може додавати не лише числа, але і рядки:
                при додаванні кількох рядків, ми отримаємо один новий.
            </p>
            <p>
                Якщо, хоча б один операнд є рядком, то інші також буде перетворено
                у рядки. Порядок операндів значення не має. Інші арифметичні оператори 
                працюють лише з числами і перетворюють операнди в числа.
            </p>
            <p>
                <b>Унарний "+"</b> перетворює в числа нечисельні операнди, а із чисельними операндами
                не виконує ніяких дій. По суті, даний оператор робить те саме, що і функція Number.
                Необхідність перетворювати рядки в числа виникає досить часто. Наприклад, 
                зазвичай значеннями полів HTML-форми є рядки.
            </p>
        </div>
    </div>

    <!-- <div class="block block3">
        <h3 class="block-title">Приорітет операторів</h3>
        <div class="block-content" >
            <p>
                У JS багато операторів і кожен має відповідний номер приорітету. Чим більший номер, тим більший приорітет. 
                Якщо ж приорітет у операторів однаковий, то вони виконуються по черзі зліва направо.
            </p>
            <p>
                Найбільший приорітет мають дужки. Приорітет унарних операторів більший аніж відповідних бінарних.
                Підведення до степеня має більший приорітет ніж множення/ділення. Найменший приорітет має 
                оператор присвоєння "=".
            </p>
        </div>
    </div> -->

    <div class="block block4">
        <h3 class="block-title">Оператор присвоєння</h3>
        <div class="block-content" >
            <p>
                Як вже було зазначено вище, у JS присвоєння "=" є оператором. Виходить, що він,
                як і інші оператори повертає значення. Завдяки цьому можна використовувати присвоєння як частину
                більш складного виразу:
            </p>
            <pre>
                <code class="language-javascript">
let a = 1;
let b = 2;
let c = 3 - (a = b + 1); // в результаті c = 0
                </code>
            </pre>
           
            <p>
                Подібні моменти можна часто зустріти в JS-бібліотеках, однак писати свій код 
                у таком стилі не рекомендується.
            </p>
            <p>
                Ще однією цікавою особливістю оператора присвоєння "=" є можливість присвоєння по ланцюжку. Працює зправа наліво.
                Спочатку вираховується останній вираз зправа і результат присвоюється змінним.
            </p>
            <pre>
                <code>
let a, b, c;
a = b = c = 2 + 2;

alert (a); // 4
alert (b); // 4
alert (c); // 4
                </code>
            </pre>
            <p>Для ліпшого читання коду, рекомедується розбивати ланцюжок на кілька рядків.</p>
        </div>
    </div>

    <div class="block block5">
        <h3 class="block-title">Суміщені оператори</h3>
        <div class="block-content" >
            <p>Використувуючи суміщені оператори, можна застосувати оператор до змінної і зберегти в неї значення водночас.</p>
            <pre>
                <code class="language-javascript">
let a = 2;
a = a + 2;

let b = 3;
b += 3;
                </code>
            </pre>
            <p>Подібні короткі форми запису існують для всіх арифметичних та побітових операторів.</p>
            <p>Присвоєння через суміщений оператор має такий самий приорітет як і звичайне присвоєння.</p>
        </div>
    </div>

    <div class="block block6">
        <h3 class="block-title">Інкремент/декремент</h3>
        <div class="block-content" >
            <p><b>Інкремент</b> - оператор, що збільшує значення змінної на одиницю.</p>
            <p><b>Декремент</b> - оператор, шо зменшує значення змінної на одиницю.</p>
            <p>
                Інкремент/декремент можна застосовувати лише до змінних. Він може розташовуватись як перед,
                так і після змінної. Незалежно від форми запису, значення змінної змінюється на 1. Різниця між 
                формами запису полягає у значенні,
                що повертається оператором:
                <ul>
                    <li>
                        <b>постфіксна форма</b> - оператор "++"/"--" йде після змінної: variable++;
                        повертає старе значення, тобто до збільшення/зменшення;
                    </li>
                    <li>
                        <b>префіксна форма</b> - оператор "++"/"--" йде перед змінною: ++variable; 
                        повертає нове значення, тобто після збільшення/зменшення;
                    </li>
                </ul>
            </p>
            <p>
                Отже, якщо результат оператора не використовується, а потрібно лише збільшити/зменшити змінну,
                тоді без різниці, яку форму використовувати.
            </p>
            <p>
                Якщо потрібно використати результат, то використовується префіксна форма.
            </p>
            <p>
                Якщо потрібно отримати значення змінної до збльшення/зменшення, використовується 
                постфіксна форма.
            </p>
            <p>
                Оператори "++/--" також можна використовувати всередині виразів. Приорітет виконання цих операторів
                більший, аніж у більшості інших арифметичних операторів.
            </p>
            <pre>
                <code class="language-javascript">
let counterA = 1;
alert (2 * ++counterA); // 4

let counterB = 1;
++counterB;
alert (2 * counterB); // 4
                </code>
            </pre>
            <p>
                В такому випадку, рекомендується для зручності читання коду використовувати стиль
                "один рядок - одна дія".
            </p>
            
        </div>
    </div>

    <div class="block block7">
        <h3 class="block-title">Оператор кома ","</h3>
        <div class="block-content" >
            <p>
                Цей оператор дає можливість обчислювати декілька виразів, розділяючи їх комою.
                Виконується кожен вираз, але повертається результат лише останнього виразу.
            </p>
            <pre>
                <code class="language-javascript">
let a = (1 + 2, 3 + 4);
alert (a); // 7 - повертає результат 3 + 4
                </code>
            </pre>
            <p>
                Кома має дуже низький приорітет - нижчий, аніж у присвоєння.
            </p>
            <p>
                Кома використовується для написання короткого коду. Іноді цей оператор викорисовують у 
                складі більш складних конструкцій, щоб виконати декілька дій в одному рядку.
            </p>
            <pre>
                <code class="language-javascript">
for (a = 1, b = 3, c = a * b; a < 10; a++) { //тут через кому виконано три операції
    // код циклу
}
                </code>
            </pre>
            <p>
                Такі прийоми часто використовується в багатьох JS-фреймворках, але, зазвичай,
                вони не покращують читання коду.
            </p>
        </div>
    </div>

    <div class="block block8">
        <h3 class="block-title">Побітові оператори</h3>
        <div class="block-content" >
           <p>
            Вони працюють із 32-розрядними цілими числами на рівні їх внутрішнього, двійкового представлення.
           </p>
           <p>
            Підтримуються наступні побітові оператори: 
            <ul>
                <li><b>AND</b> (і) - "&";</li>
                <li><b>OR</b> (або) - "|";</li>
                <li><b>XOR</b> (побітове виключаюче або) - "^";</li>
                <li><b>NOT</b> (не) - "~";</li>
                <li><b>LEFT SHIFT</b> (лівий зсув) - "<<";</li>
                <li><b>RIGHT SHIFT</b> (правий зсув) - ">>";</li>
                <li><b>ZERO-FILL RIGHT SHIFT</b> (правий зсув із заповненням нулів) - ">>>".</li>
            </ul>
           </p>
        </div>
    </div>

    <div class="block block9">
        <h3 class="block-title">Оператори порівняння</h3>
        <div class="block-content" >
            <p>
              В JS існують наступні оператори порівняння:
              <ul>
                  <li><b>більше</b>: a > b;</li>
                  <li><b>менше</b>: a < b;</li>
                  <li><b>більше-рівне</b>: a >= b;</li>
                  <li><b>менше-рівне</b>: a <= b;</li>
                  <li><b>дорівнює</b>: a = b;</li>
                  <li><b>не дорівнює</b>: a != b;</li>
                  <li><b>строге дорівнює</b>: a === b;</li>
                  <li><b>строге не дорівнює</b>: a !== b.</li>
              </ul>
            </p>
            <p>
              Всі оператори порівняння повертають значення логічного типу: 
              <ul>
                  <li><b>true</b> - "так"/"істина";</li>
                  <li><b>false</b> - "ні"/"не істина".</li>
              </ul>
            </p>
            <p>Результат порівняння можна присвоїти змінній:</p>
            <pre>
                <code class="language-javascript">
let result = 5 > 4;
alert (result); // true
                </code>
            </pre>
            <p></p>
        </div>
    </div>

    <div class="block block10">
        <h3 class="block-title">Порівняння рядків</h3>
        <div class="block-content" >
            <p>
                Щоб порівнювати рядки між собою, JS використовує алфавітний або лексикографічний порядок.
                Інакше кажучи, рядки порівюються посимвольно.
            </p>
            <pre>
                <code class="language-javascript">
alert ("В" > "А"); // true
alert ("Коти" > "Кода"); // true
alert ("Сонний" > "Сон"); // true
                </code>
            </pre>
            <p>Алгоритм порівняння рядків наступний: 
                <ul>
                    <li>спочатку порівнюється перші символи рядків;</li>
                    <li>
                        якщо перший символ першого рядка більший/менший ніж перший символ другого рядка,
                        то перший рядок більший/менший за другий рядок і порівняння завершено;
                    </li>
                    <li>якщо перші символи рядків однакові, то аналогічним чином порівнюються другі символи рядків;</li>
                    <li>порівняння продовжується, доки не завершиться один із рядків;</li>
                    <li>
                        якщо обивда рядки завершуються одночасно, то вони рівні, в протилежному випадку 
                        більшим рахується довший рядок.
                    </li>
                </ul>
            </p>
            <div class="remark">
                <p>
                    При порівнянні рядків використовується кодування Unicode, а не справжній алфавіт.
                </p>
                <p>
                    Алгортм порівняння рядків у JS подібний на алгоритм, що використовується у словниках і телефонних
                    книгах, але між ними є і відмінності.
                </p>
                <p>
                    Наприклад, у JS має значення реєстр символів. Заголовкова "А" не дорівнює рядковій "а", тому що 
                    рядкові літери мають більший код у внутрішній таблиці кодування.
                </p>
            </div>
        </div>
    </div>

    <div class="block block11">
        <h3 class="block-title">Порівняння різних типів</h3>
        <div class="block-content" >
            <p>
                При порівнянні значень різних типів, JS перетворює кожне з них в число.
            </p>
            <pre>
                <code class="language-javascript">
alert ("2" > 1); // true
alert (true == 1); // true
                </code>
            </pre>
            <p>
                При перетворенні типів даних в чисельний, true стає 1, а false стає 0.
                В результаті цього можливий цікавий наслідок:
            </p>
            <pre>
                <code class="language-javascript">
let a = 0;
alert (Boolean(a)); // false

let b = "0";
alert (Boolean(a)); // true

alert (a == b); // true
                </code>
            </pre>
            <p>Рівність між a і b перетворює нечислові значення в чисельні, тому "0" стає 0 і, відповідно 0 = 0.</p>
        </div>
    </div>

    <div class="block block12">
        <h3 class="block-title">Строге порівняння</h3>
        <div class="block-content" >
            <p>
                Оператор строгої рівності "===" перевіряє рівність без перетворення типів. 
                Якщо змінні a і b мають різні типи, то перевірка a===b поверне false, без спроби
                їх перетворення.
            </p>
            <pre>
                <code class="language-javascript">
alert (0 === false); // false
alert ("" === false); // false
                </code>
            </pre>
            <p>Також існує оператор строгої нерівності: !==.</p>
        </div>
    </div>

    <div class="block block13">
        <h3 class="block-title">Порівняння null і undefined</h3>
        <div class="block-content" >
            <p>
                Поведінка null і undefined при порівнянні із іншими значеннями особлива.
            </p>
            <div class="remark">
                <p>
                    Нагадаємо, що:
                    <ul>
                        <li>
                            <b>null</b> - це визначене значення відсутності об'єкта або відсутності значення всередині
                        об'єкта, для якого визначено ключ;
                        </li>
                        <li>
                            <b>undefined</b> - означає невизначеність, а саме те, що контейнер було створено, але його 
                            значення не було визначено, або ж властивість об'єкта не було визначено взагалі.
                        </li>
                    </ul>
                </p>
            </div>
            <p>
                При строгій рівності "===" null і undefined не рівні, так як різні їх типи.
            </p>
            <p>
                При нестрогій рівності "==" null і undefined не перетворюються, рівні один одному і не рівні жодним
                іншим значенням - це спеціальне правило JS; 
            </p>
            <pre>
                <code class="language-javascript">
alert (null === undefined); // false
alert (null == undefined); // true
                </code>
            </pre>
            <p>
                При використанні математичних операторів та інших операторів порівнння ">", "<", ">=", "<=",
                значення null/undefined перетворюються в числа: null стає 0, а undefined стає NaN.
            </p>
        </div>
    </div>

    <div class="block block14">
        <h3 class="block-title">Порівняння null і 0</h3>
        <div class="block-content" >
            <p>Якщо порівняти null і 0, ми отримаємо наступні результати:</p>
            <pre>
                <code class="language-javascript">
alert (null > 0); // (1) false
alert (null == 0); // (2) false
alert (null >= 0); // (3) true
                </code>
            </pre>
            <p>
                Порівняння перетворюють null в число, тому перший приклад (1) false і тому ж третій приклад (3) true: 
                null перетворюється в число і порівнюється з 0.
            </p>
            <p>
               Для нестрогої рівності "==" для значень null і undefined, як вже зазначалось, працює спеціальне правило:
               ці значення не перетворюються і рівні між собою, та не рівні іншим значенням, 
               саме тому у другому прикладі (2) false.
            </p>
        </div>
    </div>

    <div class="block block15">
        <h3 class="block-title">Непорівнюване значення undefined</h3>
        <div class="block-content" >
            <p>
                Якщо порівняти undefined з будь-яким іншим значенням (окрім null і іншим undefined)
                ми отримаєо наступні результати:
            </p>
            <pre>
                <code class="language-javascript">
alert (undefined > 0); // false
alert (undefined < 0); // false
alert (undefined == 0); // false
                </code>
            </pre>
            <p>
                У перший двох прикладах (1,2) undefined перетворюється у NaN, а воно повертає false при будь-яких порівняннях.
            </p>
            <p>
                У третьому прикладі (3) нестрога рівність повертає false через спеціальне правило, 
                для нестрогої рівності для undefined і null.
            </p>
        </div>
    </div>

    <div class="block block16">
        <h3 class="block-title">Як уникнути проблем</h3>
        <div class="block-content" >
          <p>
            Треба дуже обережно відноситись до будь-якого порівняння із undefined/null, окрім випадків строгої рівності "===".
          </p>
          <p>
            Не варто використовувати оператори порівння ">", "<", ">=", "<=" зі змінними, що можуть мати значення null/undefined,
            окрім випадків, коли є повна впевненість в очікуваному результаті. Також, якщо змінна приймає ці значення, то можна
            додати для них окремі перевірки.
          </p>
        </div>
    </div>

    <div class="block block17">
        <h3 class="block-title">Логічні оператори</h3>
        <div class="block-content" >
            <p>
                У JS є чотири логічних оператори: 
                <ul>
                    <li><b>||</b> - АБО;</li>
                    <li><b>&&</b> - І;</li>
                    <li><b>!</b> - НЕ;</li>
                    <li><b>??</b> - оператор об'єднання з null.</li>
                </ul>
            </p>
            <p>Дані оператори можуть використовуватись із значеннями будь-яких типів.</p>
        </div>
    </div>

    <div class="block block18">
        <h3 class="block-title">Оператор || (АБО)</h3>
        <div class="block-content" >
            <p>
                Традиційно, у програмуванні || (АБО) призначений лише для маніпуляції із булевими значеннями:
                якщо хоча б один із аргументів є true, то || (АБО) поверне true, а у протилежному випадку поверне false. 
                У JS цей оператор працює трохи інакшим чином.
            </p>
            <p>
                Всього існує чотири логічні комбінації:
            </p>
            <pre>
                <code class="language-javascript">
alert (true || true); // true
alert (false || true); // true
alert (true || false); // true
alert (false || false); // false
                </code>
            </pre>
            <p>
                Якщо значення операнда не логічного типу, то воно в нього перетворюється.
            </p>
            <p>
                Оператор || (АБО) знаходить і повертає перше істинне значення у його вихідному вигляді (тобто до перетворення).
                Якщо ж усі значення не істинні, тоді повертається останнє із них у вихідному вигляді.
            </p>
            <p>
                Оператор || (АБО) може виконутись із декількома значеннями.
            </p>
            <pre>
                <code class="language-javascript">
alert (1 || 0); // 1
alert (true || "text"); // true
alert (null || 1); // 1
alert (null || 0 || 1); // 1
alert (undefined || null || 0); // 0 - усе false, тому повертає останнє значення
                </code>
            </pre>
            <p>
                Завдяки цьому є досить цікаві варіанти застосування оператора.
            </p>
            <p>
                Можна використовувати оператор || (АБО) для отримання першого істинного значення із списку змінних чи виразів.
                Уявімо, що в нас є ряд змінних, що можуть приймати як дані, так і null/undefined:
            </p>
            <pre>
                <code class="language-javascript">
let currentUser = null;
let defaultUser = "John";

let name = currentUser || defaultUser || "unnamed";

alert (name); // John - перше істинне значення

                </code>
            </pre>
            <p>
                Якби defaultUser також було б не істинним, то в результаті ми б отримали "unnamed".
            </p>
            <p>
                Також оператор || (АБО) можна використовувати для скорочених обчислень. Оскільки операндами можуть бути
                довільні вирази, обчислення яких відбувається зліва направо і, оскільки обчислення припиняється при 
                досягненні першого істинного значення, то другий операнд буде обчислюватися лише тоді, коли першого операнда 
                недостатньо для обчислення всього виразу. Це особливо помітно, коли вираз, що вказаний в якості другого операнду,
                має побічний ефект, наприклад змінення змінної:
            </p>
            <pre>
                <code class="language-javascript">
let x;
true || (x = 1);
alert (x); // undefined, бо (x = 1) не обчислюється
                </code>
            </pre>
            <p>
                Якби перший операнд був false, тоді б оператор || (АБО) приступив би до обчислення другого виразу
                і виконав би присвоєння:
            </p>
            <pre>
                <code class="language-javascript">
let x;
false || (x = 1);
alert (x); 1
                </code>
            </pre>
            <p>
                У такому варіанті використання || (АБО) нагадує умову if: якщо перший операнд false,
                то починається обчислення другого.
            </p>
        </div>    
    </div>

    <div class="block block19">
        <h3 class="block-title">Оператор && (І)</h3>
        <div class="block-content" >
           <p>
            В традиційному програмуванні && (І) повертає true, якщо обидва аргументи істинні, - в протилежному випадку
            повертає false.
           </p>
            <pre>
                <code class="language-javascript">
alert (true && true); //true
alert (false && true); //false
alert (true && false); //false
alert (false && false); //false
                </code>
            </pre>
            <p>
                В якості операнда для && (І) допускається будь-яке значення. Цей оператор обчислює значення зліва
                направо і кожен операнд перетворює в логічне значення. Повертає перше не істинне значення або, якщо
                всі операнди були істинні, повертає останній із них (операнди повертаються у вихідному виді - до перетворення).
            </p>
            <pre>
                <code class="language-javascript">
alert (1 && 0); // 0
alert (1 && 5); //5
alert (null && 5); //null
alert (0 && "text"); //0
                </code>
            </pre>
            <p>Також оператор && (І) може працювати з декількома значеннями.</p>
            <div class="remark">
                <p>
                    Приорітет оператора && (І) більший, ніж у оператора || (АБО), оскільки && (І) - це логічне множення,
                    а || (АБО) - це логічне додавання.
                </p>
            </div>
            <p>
                Оператор && (І) також може заміняти умову if:
            </p>
            <pre>
                <code class="language-javascript">
let x = 1;
(x > 0) && alert ("Greater than zero!");
                </code>
            </pre>
            <p>
                У прикладі вище права частина спрацює, лише якщо зліва буде true. Як правило, заміняти if таким чином
                не варто, аби не погіршувати читання коду.
            </p>
        </div>
    </div>

    <div class="block block20">
        <h3 class="block-title">Оператор ! (НЕ)</h3>
        <div class="block-content" >
           <p>
                Даний оператор приймає один аргумент, перетворює його значення в логічний тип і повертає протилежне
                значення логічного типу.
           </p>
            <pre>
                <code class="language-javascript">
alert (!true); // false
alert (!0); // true
                </code>
            </pre>
            <p>
                Використовуючи оператор !! (подвійне НЕ) можна перетворити значення іншого типу в логічний тип.
            </p>
            <pre>
                <code class="language-javascript">
alert (!!"text"); // true
alert (!!null); // false
                </code>
            </pre>
            <p>
                Тобто, виходить, що перший ! (НЕ) перетворює значення в логічний тип і повертає протилежне, 
                після чого другий ! (НЕ) знову повертає протилежне і ми отримуємо просте перетворення в логічний тип.
            </p>
            <div class="remark">
                <p>
                    Як ми вже знаємо, існує вбудована функція Boolean, яка також перетворює значення в логічний тип.
                </p>
                <pre>
                    <code class="language-javascript">
alert (Boolean("text")); // true
alert(Boolean(null)); // false   
                    </code>
                </pre>
            </div>
            <p>
                Оператор ! (НЕ) має найбільший приорітет серед логічних операторів.
            </p>
        </div>    
    </div>

    <div class="block block21">
        <h3 class="block-title">Оператор ?? (нульового об'єднання/об'єднання з null)</h3>
        <div class="block-content" >
            <p>
                Даний оператор повертає перший аргумент, якщо він не є null/undefined, а в протилежному випадку
                повертає другий.
            </p>
            <pre>
                <code class="language-javascript">
let a = 0;
let b = null;
let result = a ?? b;
alert (result); //поверне змінну a, тобто значення 0
                </code>
            </pre>
            <p>
                Використовуючи вже відомі нам оператори, цей вираз можна записати наступним чином:  
            </p>
            <pre>
                <code class="language-javascript">
let a = 0;
let b = null;
let result = (a !==null && a !== undefined) ? a : b;
alert (result); // поверне змінну a, тобто значення 0
                </code>
            </pre>
            <p>
                Оператор ?? (нульового об'єднання) був доданий у JS недавно, тому у старих браузерах може виникнути потреба 
                використовувати поліфіли.
            </p>
            <div class="remark">
                <p>
                    Поліфіл - це код, що реалізовує якусь функціональність, яка не підтримується в деяких версіях веб-браузерів.
                </p>
            </div>
           <p>
                Як правило, оператор ?? (нульового об'єднання) потрібний для того, щоб задавати значення за замовчуванням
                для змінної, що може потенційно набувати значення null/undefined.
           </p>
            <pre>
                <code class="language-javascript">
let user;
alert (user ?? "Анонім"); // Анонім
                </code>
            </pre>
            <p>
                Якби у прикладі вище змінна user мала б значення відмінне від null/undefined, то alert повертала б її:
            </p>
            <pre>
                <code class="language-javascript">
let user = "John";
alert (user ?? "Анонім"); //John
                </code>
            </pre>
            <p>
                Також можна використовувати послідовність із операторів ?? (об'єднання з null), щоб отримати перше значення
                зі списку, яке не є null/undefined.
            </p>
            <pre>
                <code class="language-javascript">
let firstName = null;
let lastName = null;
let nickName = "John";
alert (firstName ?? lastName ?? nickName ?? "Анонім"); // John
                </code>
            </pre>
            <p>
                Але, як ми знаємо, оператор || (Або) можна використовувати так само, як і оператор ?? (нульового об'єднання). 
                Проте, між ними є ключова рязниця, яка полягає в тому, що || (Або) повертає перше істинне значення, 
                в той час як ?? (об'єднання з null) повертає перше значення, що не є null/undefined.
            </p>
            <p>
                Інакше кажучи, для || (Або) не існє відмінностей між false, 0, "", null/undefined - вони всі інтерпретуються як false.
                Однак, на практиці часто потрібно використовувати значення за замовчуванням лише тоді, 
                коли змінна є лише null/undefined.
            </p>
            <pre>
                <code class="language-javascript">
let height = 0;
alert (height || 100); // 100
alert (height ?? 100); // 0
                </code>
            </pre>
            <p>
                Приорітет оператора ?? (об'єднання з null) такий самий, що і у оператора || (Або), а саме 3. Тобто, вони виконуються 
                до оператора = (дорівнює) і оператора ? (тернарний умовний), але після більшості інших операторів,
                таких як +, *. Саме тому необхідно уважно слідкувати за потребою ставити дужки, коли ці оператори 
                використовуються в одному виразі.
            </p>
            <pre>
                <code class="language-javascript">
let height = null;
let width = null; 
let area = (height ?? 100) * (width ?? 50);
alert (area); // 5000
                </code>
            </pre>
            <p>
                У прикладі вище, якби не було дужок, то спочатку б обчислилось множення і ми отримали б
                не такий результат, як нам потрібно.
            </p>
            <p>
                З міркувань безпеки, у JS заборонено використовувати оператор ?? (нульового об'єднання) разом із || (Або) та && (І),
                якщо приорітет виконання явно не вказаний за допомогою дужок.
            </p>
            <pre>
                <code class="language-javascript">
let x = 1 && 2 ?? 3; // синтаксична помилка
                </code>
            </pre>
            <p>
                Таке обмеження було додано з метою запобігання програмних помилок при переході з || (Або) на ?? (об'єднання з null).
            </p>
            <pre>
                <code class="language-javascript">
let x = (1 && 2) ?? 3; // працює без помилок
alert (x); // 2
                </code>
            </pre>
        </div>    
    </div>

    <div class="block block22">
        <h3 class="block-title">Приорітет операторів. Асоціативність</h3>
        <div class="block-content" >
            <p> 
                Приорітет операторів визначає порядок, в якому вони виконуються. 
                Оператори з більшим приорітетом виконуються першими. У випадках, 
                коли оператори мають однаковий приорітет, треба керуватись їхньою асоціативністю.
            </p>
            <p>
                Асоціативність - це порядок, у якому виконуються оператори з однаковим приорітетом.
                Існують лівоасоціативні оператори - виконуються зліва направо 
                та правоасоціативні оператори - виконуються зправа наліво.
            </p>
           <div class="table_wrapper">
                <table>
                    <tr>
                        <th class="table_column column1">Оператор</th>
                        <th class="table_column column2">Приорітет</th>
                        <th class="table_column column3">Асоціативність</th>
                    </tr>

                    <tr>
                        <td class="table_column column1">Групування (...)</td>
                        <td class="table_column column2">19</td>
                        <td class="table_column column3">Невизначено</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Постфіксний інкремент/декремент</td>
                        <td class="table_column column2">16</td>
                        <td class="table_column column3">Невизначено</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Логічне заперечення ! (Не)</td>
                        <td class="table_column column2" rowspan="3">15</td>
                        <td class="table_column column3" rowspan="4"> Правоасоціативний</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Унарний +/- (плюс/мінус)</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Префіксний інкремент/декремент</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Підведення до степеня **</td>
                        <td class="table_column column2">14</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Множення *</td>
                        <td class="table_column column2" rowspan="3">13</td>
                        <td class="table_column column3" rowspan="15"> Лівоасоціативний</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Ділення /</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Частка від ділення %</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Додавання/віднімання +/-</td>
                        <td class="table_column column2">12</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Менше <</td>
                        <td class="table_column column2" rowspan="4">10</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Більше ></td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Менше-рівне <=</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Більше-рівне >=</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Рівність ==</td>
                        <td class="table_column column2" rowspan="4">9</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Нерівність !=</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Строга рівність ===</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Строга нерівність !==</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Логічне "І" &&</td>
                        <td class="table_column column2">5</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Логічне "Або" ||</td>
                        <td class="table_column column2" rowspan="2">4</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Оператор нульового об'єднання/об'єднання з null ??</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Умовний (тернарний) оператор .. ? .. : ..</td>
                        <td class="table_column column2">3</td>
                        <td class="table_column column3" rowspan="2"> Правоасоціативний</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Присвоєння =</td>
                        <td class="table_column column2">2</td>
                    </tr>

                    <tr>
                        <td class="table_column column1">Кома ,</td>
                        <td class="table_column column2">1</td>
                        <td class="table_column column3" rowspan="2"> Лівоасоціативний</td>
                    </tr>
                </table>
           </div>
           <p></p>
        </div>    
    </div>

    <script src="../../JS/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
    <script src="../../JS/script.js"></script>
    <script src="JS\script.js"></script>
</body>
</html>